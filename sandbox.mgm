//i need to play

function Paley(q)
  /*
  This function creates a Paley graph object
  Parameters: order of the Paley graph
  Returns: the constructed graph object
  */
  F<x>:= FiniteField(q);
  //Graph<Point set | edge set>
  P:= {@v: v in F@};
  G,V,E := Graph <P | {<a,{b: b in P| (a-b) ne 0 and IsSquare(a-b)}>: a in P}>;
  return G;
end function;

//main
Z:= Integers();
q:= 81;
filename := "~/Paley-Graph-text-files/p81/staircase_tight_sets_p81.txt" ;
size := Z!(Sqrt(q)-1);
p := Z!Sqrt(q);
F<x> := FiniteField(q);
G:= Paley(q);
V:= VertexSet(G);
alpha := Z!((q-1)/4);

all:= AllCliques(G,p);
//find cliques with 0
hasZero := {c: c in all | V!(F!0) in c};
TS:= {};
// one := Rep(hasZero);


//FORCE STRUCTURE ONTO P81
findF9:= {c: c in all |  V!(F!0) in c and  V!(F!1) in c and  V!(F!2) in c};
one := Rep(findF9);
Exclude(~hasZero, one);
disjoint_one := {c: c in all | #(c meet one) eq 0};
second := {p: p in disjoint_one| V!(x^64) in p};
second := Rep(second);
third := {p: p in disjoint_one | V!(x^16) in p};
third := Rep(third);
seq:= [second,one, third];
Exclude(~disjoint_one, second);
Exclude(~disjoint_one, third);
options:= Permutations(disjoint_one);
ops := {};
for perm in options do
  Include(~ops, seq cat perm);
end for;
// print #options;

other_pclass := Rep(hasZero);
Exclude(~hasZero, other_pclass);
disjoint_other := {c: c in all | #(c meet other_pclass) eq 0};
pclass2 := disjoint_other join {other_pclass};


TS:={};
maybe:= {};

for perm in ops do
  i := 8;
  build := {};
  ignore := {};
  for line in perm do
    lin:= line diff ignore;
    choice := Rep(Subsets(lin, i));
    //decrement i
    i:= i-1;
    //add those i to a set
    if #choice ne 0 then
      Include(~build, choice);
    end if;
    //parallel class fix
    difference := Rep(line diff choice); //this will be an element of one
    find := Rep({l: l in pclass2 | difference in l});
    for el in find do
      Include(~ignore, el);
    end for;
  end for;
  poss := {};
  for element in build do
    for el in element do
      Include(~poss, el);
    end for;
  end for;
  Include(~maybe, poss);
end for;
// print  maybe;

for possible in maybe do
  subgraph := sub<G | possible>;
  //check if it's a tight set
  if forall(v){v: v in possible | #(Neighbors(v) meet possible) eq alpha} then
    Include(~TS, possible);
  end if;
end for;

#TS;
