/*
This file tries to brute force construct what the affine plane could look
like for P81
The goal of this is to get to the point where we can look for a staircase in 81

Authors: Emily Barranca, Clara Buck, Lauren Hartmann
Mentor: Morgan Rodgers
July 2018
*/

////////////////////////////////*FUNCTIONS*//////////////////////////////

function Paley(q)
  /*
  This function creates a Paley graph object
  Parameters: order of the Paley graph
  Returns: the constructed graph object
  */
  F<x>:= FiniteField(q);
  //Graph<Point set | edge set>
  P:= {@v: v in F@};
  G,V,E := Graph <P | {<a,{b: b in P| (a-b) ne 0 and IsSquare(a-b)}>: a in P}>;
  return G;
end function;

function find_next_line(previous, G, disjoint_one)
  for cliq in disjoint_one do
    v := Rep(cliq);
    V:= VertexSet(G);
    //check if it's cocliquear with four in a row of the previous
    neigh := Neighbors(v) meet SequenceToSet(previous);
    counter := 0; // counts how many consecutive points on previous v is collin
    for i in {1..#previous} do
      if previous[i] in Neighbors(v) then
        if i eq 1 then
          if previous[9] in Neighbors(v) then
            counter := counter +1;
          end if;
        elif previous[i-1] in Neighbors(v) then
          counter := counter +1;
        end if;
      end if;
    end for;
    if counter eq 3 then
      return cliq;
    end if;
  end for;
  return {};
end function;

function order_next_line(previous, next, cliques)
  ret := [];
  if SequenceToSet(previous) eq {} then
    for item in next do
      ret := Append(ret, item);
    end for;
  else
    //something with cliques
    // check :=0;
    // while check eq 0 do
    //   check:= 1;
      for i in {1..9} do
        choices:= Neighbors(previous[i]) meet next;
        print choices;
        // if #choices eq 0 then
        //   check := 0;
        // else
          s := Random(choices);
          ret := Append(ret, s);
          Exclude(~next, s);
        // end if;
      end for;
    // end while;
  end if;
  return ret;
end function;

function isCocliquear(set, G)
  /*
  This function takes in a set of points and a graph probably and returns the vertices
  that are cocliquear with all the veritces in set
  Parameters: a set of picked "next to each other" vertices
  Returns: set of vertices cocliquear with all the veritces in set
  */
  V:= VertexSet(G);
  size := #set;
  ret := {v: v in V | #(Neighbors(v) meet set) eq size};
  return ret;
end function;

/////////////////////////////**MAIN**///////////////////////////////

//for loop
q:= 81;
G:= Paley(q);
F<x> := FiniteField(q);
V:= VertexSet(G);
cliques := AllCliques(G,9);
findF9:= {c: c in cliques |  V!(F!0) in c and  V!(F!1) in c and  V!(F!2) in c};

set := {V!(x^47), V!(x^22), V!(x^64), V!(x^19)};
cocliq:= isCocliquear(set, G);
one := Rep(findF9);
disjoint := {c: c in cliques | #(c meet one) eq 0};
pclass :={d: d in disjoint | #(d meet cocliq) ne 0};
print pclass;

//
// has0 := {c:c in cliques | V!(F!0) in c};
// has1 := {c:c in cliques | V!(F!1) in c};
// has10 := {c:c in cliques | V!(x^10) in c};
// has20 := {c:c in cliques | V!(x^20) in c};
// has30 := {c:c in cliques | V!(x^30) in c};
// has50 := {c:c in cliques | V!(x^50) in c};
// has60 := {c:c in cliques | V!(x^60) in c};
// has70 := {c:c in cliques | V!(x^70) in c};
// class1 := Rep(pclass);
// Exclude(~pclass, class1);
// class2 := Rep(pclass);
// Exclude(~class1, V!(x^64));
// Exclude(~class1, V!(x^78));
// Exclude(~class1, V!(x^22));
// Exclude(~class1, V!(x^19));
// Exclude(~class2, V!(x^16));
// Exclude(~class2, V!(x^38));
// Exclude(~class2, V!(x^11));
// Exclude(~class2, V!(x^23));
// c0 := {c: c in has0 | #(c meet class1) ne 0 and #(c meet class2) ne 0};
// "choices 0", c0;
// c1 := {c: c in has1 | #(c meet class1) ne 0 and #(c meet class2) ne 0};
// "choices 1", c1;
// c10 := {c: c in has10 | #(c meet class1) ne 0 and #(c meet class2) ne 0};
// "choices 10", c10;
// c20 := {c: c in has20 | #(c meet class1) ne 0 and #(c meet class2) ne 0};
// "choices 20", c20;
// c30 := {c: c in has30 | #(c meet class1) ne 0 and #(c meet class2) ne 0};
// "choices 30", c30;
// c50 := {c: c in has50 | #(c meet class1) ne 0 and #(c meet class2) ne 0};
// "choices 50", c50;
// c60 := {c: c in has60 | #(c meet class1) ne 0 and #(c meet class2) ne 0};
// "choices 60", c60;
// c70 := {c: c in has70 | #(c meet class1) ne 0 and #(c meet class2) ne 0};
// "choices 70", c70;

// // print "cliques", cliques;
// findF9:= {c: c in cliques |  V!(F!0) in c and  V!(F!1) in c and  V!(F!2) in c};
// print "cliques", findF9;
// hasZero := {c: c in cliques | V!(F!0) in c};
// one := Rep(findF9);
// Exclude(~hasZero, one);
//
// //first parallel class
// disjoint_one := {c: c in cliques | #(c meet one) eq 0};
// // Include(~one, disjoint_one);
//
// //second parallel class
// two := Rep(hasZero);
// disjoint_two := {c: c in cliques | #(c meet two) eq 0};
// two := &join{{two}, disjoint_two};
//
//
// // previous:= order_next_line([], one, cliques);
// previous := [V!(F!0), V!(F!1), V!(x^10), V!(x^20),V!(x^30), V!(F!2), V!(x^50), V!(x^60), V!(x^70)];
// print previous;
// for i in {1..8} do
//   next := find_next_line(previous, G, disjoint_one);
//   print next;
//   previous := order_next_line(previous, next, cliques);
//   print previous;
// end for;
